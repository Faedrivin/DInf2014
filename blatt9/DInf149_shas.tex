\documentclass{article}
\usepackage{type1ec}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage[ngerman]{babel}
\usepackage{amsmath, amssymb}
\usepackage{array}
\usepackage{phonetic} % for reversed D
\usepackage{tikz, tikzsymbols}
\usepackage{xcolor}
\usepackage{algorithm2e}


\usetikzlibrary{arrows,automata,fit}
\setlength\parindent{0pt}

    
\begin{document}

\begin{center}
  \Large{Informatik \revD: Übungsblatt 9}

  \large{Sebastian Höffner, Andrea Suckro}
\end{center}

\section*{Aufgabe 9.1}
Ein Beispiel für ein Wort, das weder selbstidentifizierend noch nicht selbstidentifizierend ist, ist das Wort nichtselbstidentifizierend selbst.
\begin{itemize}
  \item[1:] \textbf{nichtselbstidentifizierend ist nichtselbstidentifizierend} \\
    Wenn nichtselbstidentifizierend sich selbst nicht beschreibt, dann ist es Teil der Menge der nicht selbstidentifizierenden Wörter. Da die Wörter dieser Menge sich selbst nicht identifizieren, sind sie nichtselbstidentifizierend. Dies ist ein Widerspruch.
  \item[2:] \textbf{nichtselbstidentifizierend ist selbstidentifizierend} \\
    Wenn nichtselbstidentifizierend sich selbst beschreibt, dann ist es Teil der Menge der selbstidentifizierenden Wörter. Die Bedeutung von nichtselbstidentifizierend ist jedoch, dass ein Wort sich nicht selbst beschreibt, wodurch wir erneut einen Widerspruch haben.
\end{itemize}

\bigskip
\textit{nichtselbstidentifizierend} führt in beiden Betrachtungsweisen zum Widerspruch. Wir haben also ein Wort, dass weder zur einen, noch zur anderen Kategorie passt.

\section*{Aufgabe 9.2}
Wir prüfen für alle möglichen Eingaben, ob der Zustand $Z_i$ erreicht wird. Sobald $Z_i$ erreicht wird, gibt der Algorithmus 1 zurück. So lange wir keine gültige Eingabe finden, terminiert der Algorithmus nicht, d.h. wir können keine Aussage dazu treffen.

\begin{algorithm}[ht]
  \KwIn{Input X}
  \KwOut{1 bei Erfolg}
  \For{n = 0, 1, 2, \dots}{
    \For{$\forall w \in \Sigma^n$} {
      \If{TM reaches $Z_i$ for input w}{\Return{1}}
    }
  }
  \caption{Pseudocode zu 9.2}
\end{algorithm}

\section*{Aufgabe 9.3}
Wir können ein Programm $\mathcal{P}$ nutzen, welches terminiert, sobald 4 erreicht wird. Dieses Programm können wir mit $\mathcal{A}(\mathcal{P})$ prüfen: wenn $\mathcal{A}(\mathcal{P}) = 1$, dann ist die Collatzvermutung wahr, sonst nicht.
\begin{algorithm}[ht]
  \KwIn{Input n}
  \KwOut{1 bei Erreichen von 4}
  \While{$n \neq 4$}{
    n := C(n)\;
  }
  \Return{1}
  \caption{Pseudocode zu Programm $\mathcal{P}$ von 9.3}
\end{algorithm}

\section*{Aufgabe 9.4}

\section*{Aufgabe 9.5}
\subsection*{a)}
Diese Instanz hat eine Lösung und zwar: \textsc{wein hier und bier dort}.
\subsection*{b)}
Für diese Instanz lässt sich keine Lösung finden, da sich eins von diesen beiden Mustern (abhängig vom Startstein) für immer wiederholt: $p(am)^*$ oder $p(aamm)^*$
\bigskip
\emph{Alternative:} Betrachten wir die Steine ebenfalls als Tupel $(x_i,y_i)$. Dann kann es verschiedene Fälle geben, wie $|x_i|$ und $|y_i|$ zusammenhängen.

In den einfachsten entscheidbaren Fällen gilt entweder $\forall i: |x_i| < |y_i|$ oder $\forall i: |x_i| > |y_i|$. Dann ist es \emph{nicht} möglich, Lösungen zu finden, da immer eine "`Seite"' länger wird, als die andere.

Der zweite Fall ist, dass es entweder gilt $\forall i: |x_i| \leq |y_i|$ oder $\forall i: |x_i| \geq |y_i|$. Diese Fälle können wir vereinfachen, da für die Lösung nur die Fälle $\forall i: |x_i| = |y_i|$ interessant sind, ansonsten haben wir das selbe Problem wie in den ersten Fällen: Eine "`Seite"' würde länger, als die andere. Das heißt, wir können alle Tupel $\forall i: |x_i| \neq |y_i|$ entfernen und auf den verbliebenen Tupeln nach der Lösung suchen. Diese Tupel fallen in den nächsten Fall:

Damit wir eine Folge als Lösung finden können, muss in mindestens einer beliebigen Kombination $\sum_j^n |x_{i_j}| = \sum_j^n |y_{i_j}|$ gegeben sein. Dazu können $|x_i|$ und $|y_i|$ beliebig zueinander stehen, da wir sie beliebig kombinieren können. Auf dem nach diesen Fallunterscheidungen noch sinnvollen Tupeln kann nun nach einer Lösung gesucht werden.

In unserem konkreten Beispiel können wir nach der Argumentation oben drei Tupel ($(p,aam),(p,paa),(pa,pam)$) eliminieren, es bleiben übrig $(a,m)$ und $(m,a)$. 

Startet man mit einem Tupel, kann man nun das selbe oder das andere der beiden Tupel davor oder dahinter hängen, in beiden Fällen ist es nicht möglich, in beiden Wörtern das selbe Wort zu erzeugen. 

Verwenden wir einen Homomorphismus (zur Veranschaulichung) und ersetzen $h(a)=1$ und $h(m)=0$ und betrachten die generierten Wörter $x$, $y$ mit $(x_i,y_i)^*=x,y)$ als Bitdarstellungen auf denen der Operator $\neg b$ alle Bits invertiert, also 1 in 0 konvertiert und umgekehrt, so sind in jeder Möglichkeit $x$ und $y$ in folgender Beziehung zueinander: $x=\neg y$.




\section*{Aufgabe 9.6}





\end{document}