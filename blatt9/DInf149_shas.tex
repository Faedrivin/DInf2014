\documentclass{article}
\usepackage{type1ec}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage[ngerman]{babel}
\usepackage{amsmath, amssymb}
\usepackage{array}
\usepackage{phonetic} % for reversed D
\usepackage{tikz, tikzsymbols}
\usepackage{xcolor}
\usepackage{algorithm2e}


\usetikzlibrary{arrows,automata,fit}
\setlength\parindent{0pt}

    
\begin{document}

\begin{center}
  \Large{Informatik \revD: Übungsblatt 9}

  \large{Sebastian Höffner, Andrea Suckro}
\end{center}

\section*{Aufgabe 9.1}
Ein Beispiel für ein Wort, das weder selbstidentifizierend noch nicht selbstidentifizierend ist, ist das Wort nichtselbstidentifizierend selbst.
\begin{itemize}
  \item[1:] \textbf{nichtselbstidentifizierend ist nichtselbstidentifizierend} \\
    Wenn nichtselbstidentifizierend sich selbst nicht beschreibt, dann ist es Teil der Menge der nicht selbstidentifizierenden Wörter. Da die Wörter dieser Menge sich selbst nicht identifizieren, sind sie nichtselbstidentifizierend. Dies ist ein Widerspruch.
  \item[2:] \textbf{nichtselbstidentifizierend ist selbstidentifizierend} \\
    Wenn nichtselbstidentifizierend sich selbst beschreibt, dann ist es Teil der Menge der selbstidentifizierenden Wörter. Die Bedeutung von nichtselbstidentifizierend ist jedoch, dass ein Wort sich nicht selbst beschreibt, wodurch wir erneut einen Widerspruch haben.
\end{itemize}

\bigskip
\textit{nichtselbstidentifizierend} führt in beiden Betrachtungsweisen zum Widerspruch. Wir haben also ein Wort, dass weder zur einen, noch zur anderen Kategorie passt.

\section*{Aufgabe 9.2}
Wir prüfen für alle möglichen Eingaben, ob der Zustand $Z_i$ erreicht wird. Sobald $Z_i$ erreicht wird, gibt der Algorithmus 1 zurück. So lange wir keine gültige Eingabe finden, terminiert der Algorithmus nicht, d.h. wir können keine Aussage dazu treffen.

\begin{algorithm}[ht]
  \KwIn{Input X}
  \KwOut{1 bei Erfolg}
  \For{n = 0, 1, 2, \dots}{
    \For{$\forall w \in \Sigma^n$} {
      \If{TM reaches $Z_i$ for input w}{\Return{1}}
    }
  }
  \caption{Pseudocode zu 9.2}
\end{algorithm}

\section*{Aufgabe 9.3}
Wir können ein Programm $\mathcal{P}$ nutzen, welches terminiert, sobald 4 erreicht wird. Dieses Programm können wir mit $\mathcal{A}(\mathcal{P})$ prüfen: wenn $\mathcal{A}(\mathcal{P}) = 1$, dann ist die Collatzvermutung wahr, sonst nicht.
\begin{algorithm}[ht]
  \KwIn{Input n}
  \KwOut{1 bei Erreichen von 4}
  \While{$n \neq 4$}{
    n := C(n)\;
  }
  \Return{1}
  \caption{Pseudocode zu Programm $\mathcal{P}$ von 9.3}
\end{algorithm}

\section*{Aufgabe 9.4}

\section*{Aufgabe 9.5}
\subsection*{a)}
Diese Instanz hat eine Lösung und zwar: wein hier und bier dort
\subsection*{b)}
Für diese Instanz lässt sich keine Lösung finden, da sich eins von diesen beiden Mustern (abhängig vom Startstein) für immer wiederholt: $p(am)^*$ oder $p(aamm)^*$
\end{document}

